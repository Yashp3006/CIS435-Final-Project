# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BfexEaLO4BK79NZ39pymWUjsN56I4_7F
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
from collections import Counter
from sklearn.metrics.cluster import contingency_matrix

# Function to calculate Sum of Squared Errors (SSE)
def calculate_sse(data, labels, centers):
    sse = 0.0
    for i in range(len(centers)):
        cluster_points = data[labels == i]
        sse += np.sum((cluster_points - centers[i]) ** 2)
    return sse

# Optimized Purity Score using Contingency Matrix
def purity_score(y_true, y_pred):
    matrix = contingency_matrix(y_true, y_pred)
    return np.sum(np.amax(matrix, axis=0)) / np.sum(matrix)

# Cluster-wise purity calculation
def cluster_purity(y_true, y_pred):
    matrix = contingency_matrix(y_true, y_pred)
    cluster_info = []

    for cluster_id in range(matrix.shape[1]):  # Iterate through each cluster
        cluster_size = np.sum(matrix[:, cluster_id])  # Total points in this cluster
        if cluster_size == 0:
            purity = 0.0
        else:
            max_class_count = np.max(matrix[:, cluster_id])  # Count of dominant class
            purity = max_class_count / cluster_size

        dominant_class = np.argmax(matrix[:, cluster_id])  # Index of dominant class
        cluster_info.append((cluster_id, cluster_size, dominant_class, purity))

    return cluster_info

# Bisecting K-means Implementation
def bisecting_kmeans(data, k=3, trials=5):
    clusters = [data]
    labels_list = [np.zeros(len(data), dtype=int)]

    while len(clusters) < k:
        # Select cluster with highest SSE for splitting
        max_sse = -1
        cluster_to_split = -1

        for i, cluster in enumerate(clusters):
            km = KMeans(n_clusters=1, random_state=42).fit(cluster)
            sse = calculate_sse(cluster, np.zeros(len(cluster)), km.cluster_centers_)
            if sse > max_sse:
                max_sse = sse
                cluster_to_split = i

        best_sse = float('inf')
        best_kmeans = None

        # Perform multiple trial bisections and choose the best
        for _ in range(trials):
            km = KMeans(n_clusters=2, random_state=42).fit(clusters[cluster_to_split])
            sse = calculate_sse(clusters[cluster_to_split], km.labels_, km.cluster_centers_)
            if sse < best_sse:
                best_sse = sse
                best_kmeans = km

        # Split the cluster and replace with two new clusters
        data_to_split = clusters.pop(cluster_to_split)
        labels_to_split = labels_list.pop(cluster_to_split)

        for i in [0, 1]:
            clusters.append(data_to_split[best_kmeans.labels_ == i])
            labels_list.append(best_kmeans.labels_[best_kmeans.labels_ == i])

    # Assign final cluster labels to all data points
    final_labels = np.zeros(len(data), dtype=int)
    for i, cluster in enumerate(clusters):
        for idx in range(len(cluster)):
            final_labels[np.where((data == cluster[idx]).all(axis=1))[0][0]] = i

    return final_labels

# Plot Clusters with Distinct Markers
def plot_clusters(data, labels, title="Bisecting K-Means Clustering"):
    plt.figure(figsize=(8, 6))
    unique_labels = np.unique(labels)
    colors = plt.cm.tab10(np.linspace(0, 1, len(unique_labels)))

    for i, cluster in enumerate(unique_labels):
        plt.scatter(data[labels == cluster, 0], data[labels == cluster, 1],
                    color=colors[i], label=f'Cluster {cluster}',
                    marker='o' if cluster == 0 else 'x')

    plt.title(title)
    plt.xlabel("Feature 1 (Standardized)")
    plt.ylabel("Feature 2 (Standardized)")
    plt.legend()
    plt.show()

# Run Bisecting K-means on Iris Dataset
def run_bisecting_kmeans(file_path, k=3, trials=5):
    df = pd.read_csv('/content/iris.txt')
    X = df.iloc[:, :-1].values  # Extract features
    y = df.iloc[:, -1].values   # Extract labels

    # Standardize the data for better performance
    X = StandardScaler().fit_transform(X)

    # Run Bisecting K-means
    labels = bisecting_kmeans(X, k, trials)

    # Calculate overall purity score
    purity = purity_score(y, labels)
    print(f"Purity Score: {purity:.4f}")

    # Plot clusters
    plot_clusters(X, labels)

    # Calculate and display cluster-wise purity
    cluster_details = cluster_purity(y, labels)
    print("\nCluster-wise Purity Details:")
    print(f"{'Cluster':<10}{'Size':<10}{'Dominant Class':<20}{'Purity':<10}")

    for cluster_id, cluster_size, dominant_class, purity in cluster_details:
        class_name = ['Iris-setosa', 'Iris-versicolor', 'Iris-virginica'][dominant_class]
        print(f"{cluster_id:<10}{cluster_size:<10}{class_name:<20}{purity:.2f}")

    return labels, purity

# Main block to execute the code
if __name__ == "__main__":
    run_bisecting_kmeans('iris.csv', k=3, trials=5)